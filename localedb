#!/bin/bash

# ----------------------------------------------------------------------------------------------------------------------
#
# LocaleDB management script.
#
# Types of data currently in the database:
#
# - 2010 US synthetic population (MIDAS program; based on the 2005-2010 US Census data)
# - US Census geographic and cartographic data (TIGER2010)
#
# ----------------------------------------------------------------------------------------------------------------------
#
# Contributors
#     Tomek D Loboda; 2020.06.08 - present
#         The original idea, design, and implementation
#
# ----------------------------------------------------------------------------------------------------------------------
#
# Dependencies (development environment)
#     curl or wget
#     docker
#     PostgreSQL client
#
# Dependencies (production environment)
#     curl or wget
#     PostgreSQL client
#     PostgreSQL server (with PostGIS extensions)
#     Python 3
#
# ----------------------------------------------------------------------------------------------------------------------
#
# TODO
#     Implement fs_download_unzip() below
#     Compose a Docker container with shp2pgsql and Python already inside
#     Move most of the functionality from this script into the container
#         This will likely remove psql dependency on dev env
#
# ----------------------------------------------------------------------------------------------------------------------

set -e

declare -r is_prod=0
declare -r is_verbose=0

declare -r pg_host=localhost
declare -r pg_port=5433
declare -r pg_schema_disdyn=disdyn
declare -r pg_schema_interv=interv
declare -r pg_schema_geo=geo
declare -r pg_schema_pop=pop
declare -r pg_db=c19
declare -r pg_usr=postgres
declare -r pg_pwd=sa
declare -t pg_conn_str=postgresql://${pg_usr}:${pg_pwd}@${pg_host}:${pg_port}/${pg_db}

declare -r dir_root=$HOME/.localedb
declare -r dir_dl_geo=$dir_root/dl/geo
declare -r dir_dl_pop=$dir_root/dl/pop
declare -r dir_dl_disdyn=$dir_root/dl/disdyn
declare -r dir_dl_interv=$dir_root/dl/interv
declare -r dir_rt=$dir_root/rt
declare -r dir_script=$dir_root/script
declare -r dir_pg_data=$dir_root/pg

declare -r dir_root_docker=/mnt/localedb
declare -r dir_rt_docker=$dir_root_docker/rt
declare -r dir_script_docker=$dir_root_docker/script
declare -r dir_pg_data_docker=/var/lib/postgresql/data

declare -r docker_cont=localedb

declare -r self_name=$(basename $0)
declare -r self_path=$(dirname $0)
declare -r cmd=$1
declare -r usage="Usage: $self_name $cmd"

if [ $(command -v curl) ]; then
    declare -r cmd_dl="curl -sO"
elif [ $(command -v wget) ]; then
    declare -r cmd_dl="wget -qO"
fi

if [ $is_prod == 1 ]; then
    declare -r cmd_shp2pgsql="shp2pgsql -W \"latin1\" -a -s 4269 $dir_rt"
    declare -r cmd_py="python3 $dir_script/localedb_man.py $pg_host 5432 $pg_usr $pg_pwd $pg_db $pg_schema_geo $pg_schema_pop $dir_rt"
else
    declare -r cmd_shp2pgsql="docker exec $docker_cont shp2pgsql -W \"latin1\" -a -s 4269 $dir_rt_docker"
    declare -r cmd_py="docker exec $docker_cont python3 $dir_script_docker/localedb_man.py $pg_host 5432 $pg_usr $pg_pwd $pg_db $pg_schema_geo $pg_schema_pop $dir_rt_docker"
fi

[ $is_verbose == 1 ] && declare -r out=" /dev/stdin" || declare -r out=" /dev/null"
    
declare -a st_name=("AL" "AK" "AZ" "AR" "CA" "CO" "CT" "DE" "DC" "FL" "GA" "HI" "ID" "IL" "IN" "IA" "KS" "KY" "LA" "ME" "MD" "MA" "MI" "MN" "MS" "MO" "MT" "NE" "NV" "NH" "NJ" "NM" "NY" "NC" "ND" "OH" "OK" "OR" "PA" "RI" "SC" "SD" "TN" "TX" "UT" "VT" "VA" "WA" "WV" "WI" "WY")
    # "AS" "GU" "MP" "PR" "VI" -- in 'geo' but not 'pop' so skipping

declare -a st_fips=("01" "02" "04" "05" "06" "08" "09" "10" "11" "12" "13" "15" "16" "17" "18" "19" "20" "21" "22" "23" "24" "25" "26" "27" "28" "29" "30" "31" "32" "33" "34" "35" "36" "37" "38" "39" "40" "41" "42" "44" "45" "46" "47" "48" "49" "50" "51" "53" "54" "55" "56")
    # "60" "66" "69" "72" "78" -- in 'geo' but not 'pop' so skipping

declare -r url_geo_st="https://www2.census.gov/geo/tiger/TIGER2010/STATE/2010/tl_2010_us_state10.zip"
declare -r url_geo_co="https://www2.census.gov/geo/tiger/TIGER2010/COUNTY/2010/tl_2010_us_county10.zip"
declare -a url_geo_tr=("https://www2.census.gov/geo/tiger/TIGER2010/TRACT/2010/tl_2010_" "_tract10.zip")
declare -a url_geo_bg=("https://www2.census.gov/geo/tiger/TIGER2010/BG/2010/tl_2010_" "_bg10.zip")
declare -a url_geo_bl=("https://www2.census.gov/geo/tiger/TIGER2010/TABBLOCK/2010/tl_2010_" "_tabblock10.zip")

declare -a url_pop=("https://gitlab.com/momacs/dataset-pop-us-2010-midas/-/raw/master/zip/" ".zip")

declare -r sql_schema_geo="
    BEGIN;
    
    DROP SCHEMA IF EXISTS $pg_schema_geo CASCADE;
    CREATE SCHEMA $pg_schema_geo;
    
    CREATE SEQUENCE IF NOT EXISTS geo.st_gid_seq;
    CREATE SEQUENCE IF NOT EXISTS geo.co_gid_seq;
    CREATE SEQUENCE IF NOT EXISTS geo.tr_gid_seq;
    CREATE SEQUENCE IF NOT EXISTS geo.bg_gid_seq;
    CREATE SEQUENCE IF NOT EXISTS geo.bl_gid_seq;
    
    CREATE TABLE $pg_schema_geo.st (
    gid        int4 PRIMARY KEY DEFAULT nextval('geo.st_gid_seq'::regclass),
    region10   varchar(2),
    division10 varchar(2),
    statefp10  varchar(2),
    statens10  varchar(8),
    geoid10    varchar(2),
    stusps10   varchar(2),
    name10     varchar(100),
    lsad10     varchar(2),
    mtfcc10    varchar(5),
    funcstat10 varchar(1),
    aland10    float8,
    awater10   float8,
    intptlat10 varchar(11),
    intptlon10 varchar(12),
    geom       geometry
    );
    
    CREATE TABLE $pg_schema_geo.co (
    gid        int4 PRIMARY KEY DEFAULT nextval('geo.co_gid_seq'::regclass),
    statefp10  varchar(2),
    countyfp10 varchar(3),
    countyns10 varchar(8),
    geoid10    varchar(5),
    name10     varchar(100),
    namelsad10 varchar(100),
    lsad10     varchar(2),
    classfp10  varchar(2),
    mtfcc10    varchar(5),
    csafp10    varchar(3),
    cbsafp10   varchar(5),
    metdivfp10 varchar(5),
    funcstat10 varchar(1),
    aland10    float8,
    awater10   float8,
    intptlat10 varchar(11),
    intptlon10 varchar(12),
    geom       geometry
    );
    
    CREATE TABLE $pg_schema_geo.tr (
    gid        int4 PRIMARY KEY DEFAULT nextval('geo.tr_gid_seq'::regclass),
    statefp10  varchar(2),
    countyfp10 varchar(3),
    tractce10  varchar(6),
    geoid10    varchar(11),
    name10     varchar(7),
    namelsad10 varchar(20),
    mtfcc10    varchar(5),
    funcstat10 varchar(1),
    aland10    float8,
    awater10   float8,
    intptlat10 varchar(11),
    intptlon10 varchar(12),
    geom       geometry
    );
    
    CREATE TABLE $pg_schema_geo.bg (
    gid        int4 PRIMARY KEY DEFAULT nextval('geo.bg_gid_seq'::regclass),
    statefp10  varchar(2),
    countyfp10 varchar(3),
    tractce10  varchar(6),
    blkgrpce10 varchar(1),
    geoid10    varchar(12),
    namelsad10 varchar(13),
    mtfcc10    varchar(5),
    funcstat10 varchar(1),
    aland10    float8,
    awater10   float8,
    intptlat10 varchar(11),
    intptlon10 varchar(12),
    geom       geometry
    );
    
    CREATE TABLE $pg_schema_geo.bl (
    gid        int4 PRIMARY KEY DEFAULT nextval('geo.bl_gid_seq'::regclass),
    statefp10  varchar(2),
    countyfp10 varchar(3),
    tractce10  varchar(6),
    blockce10  varchar(4),
    geoid10    varchar(15),
    name10     varchar(10),
    mtfcc10    varchar(5),
    ur10       varchar(1),
    uace10     varchar(5),
    uatyp10    varchar(1),
    funcstat10 varchar(1),
    aland10    float8,
    awater10   float8,
    intptlat10 varchar(11),
    intptlon10 varchar(12),
    geom       geometry
    );
    
    CREATE INDEX st__geom_idx ON $pg_schema_geo.st USING GIST(geom);
    CREATE INDEX co__geom_idx ON $pg_schema_geo.co USING GIST(geom);
    CREATE INDEX tr__geom_idx ON $pg_schema_geo.tr USING GIST(geom);
    CREATE INDEX bg__geom_idx ON $pg_schema_geo.bg USING GIST(geom);
    CREATE INDEX bl__geom_idx ON $pg_schema_geo.bl USING GIST(geom);
    
    COMMIT;
"

# The schema of the original synthetic population data has been updated (see comments below):
declare -r sql_schema_pop="
    BEGIN;
    
    DROP SCHEMA IF EXISTS $pg_schema_pop CASCADE;
    CREATE SCHEMA $pg_schema_pop;
    
    CREATE TABLE $pg_schema_pop.school (  -- tbl renamed from: schools
    id      integer PRIMARY KEY,          -- col renamed from: sp_id
    st_fips varchar(2),                   -- col added
    stco    text NOT NULL,
    lat     double precision NOT NULL,    -- col renamed from: latitude
    long    double precision NOT NULL,    -- col renamed from: longitude
    coords  geometry                      -- col added
    );
    
    CREATE TABLE $pg_schema_pop.hospital (    -- tbl renamed from: hospitals
    id            integer PRIMARY KEY,        -- col renamed from: hosp_id
    st_fips       varchar(2),                 -- col added
    worker_cnt    smallint NOT NULL,
    physician_cnt smallint NOT NULL,
    bed_cnt       smallint NOT NULL,
    lat           double precision NOT NULL,  -- col renamed from: latitude
    long          double precision NOT NULL,  -- col renamed from: longitude
    coords        geometry                    -- col added
    );
    
    CREATE TABLE $pg_schema_pop.household (  -- tbl renamed from: households
    id       integer PRIMARY KEY,            -- col renamed from: hh_id
    st_fips  varchar(2),                     -- col added
    stcotrbg text NOT NULL,
    race_id  smallint NOT NULL,              -- col renamed from: hh_race
    income   integer NOT NULL,               -- col renamed from: hh_income
    lat      double precision NOT NULL,      -- col renamed from: latitude
    long     double precision NOT NULL,      -- col renamed from: longitude
    coords   geometry                        -- col added
    );
    
    CREATE TABLE $pg_schema_pop.gq (
    id         integer PRIMARY KEY,        -- col renamed from: sp_id
    st_fips    varchar(2),                 -- col added
    type       text NOT NULL,              -- col renamed from: gq_type
    stcotrbg   text NOT NULL,
    person_cnt smallint NOT NULL,
    lat        double precision NOT NULL,  -- col renamed from: latitude
    long       double precision NOT NULL,  -- col renamed from: longitude
    coords     geometry                    -- col added
    );
    
    CREATE TABLE $pg_schema_pop.workplace (  -- tbl renamed from: workplaces
    id      integer PRIMARY KEY,             -- col renamed from: sp_id
    st_fips varchar(2),                      -- col added
    lat     double precision NOT NULL,       -- col renamed from: latitude
    long    double precision NOT NULL,       -- col renamed from: longitude
    coords  geometry                         -- col added
    );
    
    CREATE TABLE $pg_schema_pop.person (                                                                         -- tbl renamed from: people
    id           integer PRIMARY KEY,                                                                            -- col renamed from: sp_id
    household_id integer NOT NULL REFERENCES $pg_schema_pop.household (id) ON DELETE CASCADE ON UPDATE CASCADE,  -- col renamed from: sp_hh_id
    age          smallint NOT NULL,
    sex          char(1) NOT NULL,
    race_id      smallint NOT NULL,                                                                        -- col renamed from: race
    relate_id    smallint NOT NULL,                                                                        -- col renamed from: relate
    school_id    integer REFERENCES $pg_schema_pop.school    (id) ON DELETE CASCADE ON UPDATE CASCADE,
    workplace_id integer REFERENCES $pg_schema_pop.workplace (id) ON DELETE CASCADE ON UPDATE CASCADE
    );
    
    CREATE TABLE $pg_schema_pop.gq_person (                                                         -- tbl renamed from: gq_people
    id     integer NOT NULL PRIMARY KEY,                                                            -- col renamed from: sp_id
    gq_id  integer NOT NULL REFERENCES $pg_schema_pop.gq (id) ON DELETE CASCADE ON UPDATE CASCADE,  -- col renamed from: sp_gq_id
    age    smallint NOT NULL,
    sex    char(1) NOT NULL
    );
    
    CREATE INDEX person__household_id__fk_idx ON $pg_schema_pop.person    (household_id);
    CREATE INDEX person__school_id__fk_idx    ON $pg_schema_pop.person    (school_id);
    CREATE INDEX person__workplace_id__fk_idx ON $pg_schema_pop.person    (workplace_id);
    CREATE INDEX gq_person__gq_id__fk_idx     ON $pg_schema_pop.gq_person (gq_id);
    
    CREATE INDEX school__geom_idx    ON $pg_schema_pop.school    USING GIST(coords);
    CREATE INDEX hospital__geom_idx  ON $pg_schema_pop.hospital  USING GIST(coords);
    CREATE INDEX household__geom_idx ON $pg_schema_pop.household USING GIST(coords);
    CREATE INDEX gq__geom_idx        ON $pg_schema_pop.gq        USING GIST(coords);
    CREATE INDEX workplace__geom_idx ON $pg_schema_pop.workplace USING GIST(coords);
    
    COMMIT;
"

declare -r sql_schema_disdyn="
    BEGIN;
    
    DROP SCHEMA IF EXISTS $pg_schema_disdyn CASCADE;
    CREATE SCHEMA $pg_schema_disdyn;
    
    -- ...
    
    COMMIT;
"

declare -r sql_schema_interv="
    BEGIN;
    
    DROP SCHEMA IF EXISTS $pg_schema_interv CASCADE;
    CREATE SCHEMA $pg_schema_interv;
    
    -- ...
    
    COMMIT;
"


# ----------------------------------------------------------------------------------------------------------------------
conf_yn() { read -p "$1 [y/n] " res; [ "$res" == "y" -o "$res" == "Y" ] && return 0 || return 1; }


# ----------------------------------------------------------------------------------------------------------------------
db_analyze() {
    echo -n "Analyzing database..."
    psql $pg_conn_str -q -c "VACUUM ANALYZE;"
    echo " done"
}


# ----------------------------------------------------------------------------------------------------------------------
#
# $1 flag: do force?
#
db_init() {
    [ "$1" != "1" ] && req_y "Reinitialize the database?"
    
    PGPASSWORD=$pg_pwd dropdb   -h $pg_host -p $pg_port -U $pg_usr --if-exists $pg_db
    PGPASSWORD=$pg_pwd createdb -h $pg_host -p $pg_port -U $pg_usr             $pg_db
    psql $pg_conn_str -q -c "CREATE EXTENSION IF NOT EXISTS postgis;"
    
    db_init_geo 1
    db_init_pop 1
}


# ----------------------------------------------------------------------------------------------------------------------
#
# $1 flag: do force?
#
db_init_geo() {
    [ "$1" != "1" ] && req_y "Reinitialize the geographic part of the database?"
    
    psql $pg_conn_str -q -c "$sql_schema_geo" > /dev/null 2>&1
    psql $pg_conn_str -q -c "VACUUM FULL;"
}


# ----------------------------------------------------------------------------------------------------------------------
#
# $1 flag: do force?
#
db_init_pop() {
    [ "$1" != "1" ] && req_y "Reinitialize the population part of the database?"
    
    psql $pg_conn_str -q -c "$sql_schema_pop" > /dev/null 2>&1
    psql $pg_conn_str -q -c "VACUUM FULL;"
}


# ----------------------------------------------------------------------------------------------------------------------
# TODO
#
# $1: file URL
# $2: dir
#
fs_download_unzip() {
    return 0
}


# ----------------------------------------------------------------------------------------------------------------------
get_tbl_rec_cnt() { echo $(psql $pg_conn_str -q -t -c "SELECT COUNT(*) FROM $1.$2;" | sed -e '$d' | bc); }
get_int() { echo $(psql $pg_conn_str -q -t -c "$1" | sed -e '$d' | bc); }

                                                                                      
# ----------------------------------------------------------------------------------------------------------------------
is_cmd() { command -v $1 > /dev/null 2>&1 && return 0 || return 1; }
is_db_tbl() { echo $(psql $pg_conn_str -q -t -c "SELECT CASE WHEN (SELECT to_regclass('$1.$2')) IS NULL THEN 0 ELSE 1 END;"); }


# ----------------------------------------------------------------------------------------------------------------------
#
# Args:
#   $1 entity name
#   $2 file url
#   $3 database table
#   $4 state FIPS code [opt]
#
proc_item_geo() {
    [ "$3" == "st" -o "$3" == "co" ] && [ $(is_db_tbl $pg_schema_geo $3) == 1 ] && [ $(get_tbl_rec_cnt $pg_schema_geo $3) -gt 0 ] && return 0
    
    local fname=$(basename $2 .zip)
    
    # Download:
    local attempt=""
    local i=1
    while [ ! -f $dir_dl_geo/$fname.zip ]; do
        echo -e -n "\r$1  downloading...$attempt"
        cd $dir_dl_geo
        $cmd_dl $2
        if [ $? -ne 0 ]; then
            rm -f $dir_dl_pop/$fname.zip
            rm $2
            i=$(echo "$i + 1" | bc)
            attempt=" (attempt $i)"
        fi
        cd - > /dev/null
    done
    
    # Process and import:
    echo -e -n "\r$1  importing...                    \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
    
    mkdir -p $dir_rt
    rm -fr $dir_rt/*
    
    unzip -q $dir_dl_geo/$fname.zip -d $dir_rt
    
    [ "$4" != "" ] && psql $pg_conn_str -q -c "DELETE FROM $pg_schema_geo.$3 WHERE statefp10 = '$4'"
    #$shp2pgsql -W "latin1" -a -s 4269 $dir_rt_/$fname.shp $pg_schema_geo.$3 2> $out | psql $pg_conn_str -q > $out
    $cmd_shp2pgsql/$fname.shp $pg_schema_geo.$3 2> $out | psql $pg_conn_str -q > $out
    
    rm -fr $dir_rt/*
    echo -e "\r$1  done                                         "
}


# ----------------------------------------------------------------------------------------------------------------------
#
# Args:
#   $1 entity name
#   $2 file url
#   $3 state FIPS code
#
proc_item_pop() {
    local fname=$(basename $2 .zip)
    
    # Download:
    local attempt=""
    local i=1
    while [ ! -f $dir_dl_pop/$fname.zip ]; do
        echo -e -n "\r$1  downloading...$attempt"
        cd $dir_dl_pop
        curl -sO $2
        $cmd_dl $2
        if [ $? -ne 0 ]; then
            rm -f $dir_dl_pop/$fname.zip
            i=$(echo "$i + 1" | bc)
            attempt=" (attempt $i)"
        fi
        cd - > /dev/null
    done
    
    # Process and import:
    echo -e -n "\r$1  importing...                    \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
    
    mkdir -p $dir_rt
    rm -fr $dir_rt/*
    
    unzip -q $dir_dl_pop/$fname.zip -d $dir_rt
    
    $cmd_py import-pop-state $3 > $out
    
    rm -fr $dir_rt/*
    echo -e "\r$1  done                                         "
}


# ----------------------------------------------------------------------------------------------------------------------
req_argn() { [ $1 -lt $2 ] && { echo "$usage $3"; exit 1; }; return 0; }
req_cmd() { command -v $1 >/dev/null 2>&1 || { echo >&2 "Command $1 not found."; exit 1; }; return 0; }
req_state_name() { [ "$1" != "-" ] && [[ ! " ${st_name[@]} " =~ " $1 " ]] && { echo >&2 "No state '$1' found."; exit 1; }; return 0; }
req_y() { read -p "$1 [y/n] " res; [ "$res" != "y" -a "$res" != "Y" ] && exit 1; return 0; }


# ----------------------------------------------------------------------------------------------------------------------
st_name2idx() { echo ${st_name[@]/$1//} | cut -d/ -f1 | wc -w | tr -d ' '; }
st_name2fips() { i=$(st_name2idx $1); echo "${st_fips[@]:$i:1}"; }


# ----------------------------------------------------------------------------------------------------------------------
! is_cmd curl   && ! is_cmd wget && echo "Dependency unmet: curl or wget" && exit 1
! is_cmd docker &&                  echo "Dependency unmet: docker"       && exit 1


# ----------------------------------------------------------------------------------------------------------------------
case "$cmd" in
    "db")
        case "$2" in
            "conn")
                psql $pg_conn_str
                ;;
            "exec")
                req_argn $# 3 "$2 <sql-query>"
                # TODO: if [[ "$3" =~ .*"INSERT".* ]]; then
                psql $pg_conn_str -q -t -c "$3"
                ;;
            "init")
                db_init $3
                ;;
            "init-geo")
                db_init_geo $3
                ;;
            "init-pop")
                db_init_pop $3
                ;;
            "rm")
                case "$3" in
                    "state")
                        req_argn $# 4 "$2 $3 <state> [force?]"
                        req_state_name $4
                        
                        [ "$5" != "1" ] && req_y "Remove all data for $4?"
                        
                        $0 $cmd rm-state-geo $4 1 0
                        $0 $cmd rm-state-pop $4 1 0
                        db_analyze
                        ;;
                    "state-geo")
                        req_argn $# 4 "$2 $3 <state> [force?]"
                        req_state_name $4
                        
                        [ "$5" != "1" ] && req_y "Remove geographic data for $4?"
                        
                        fips=$(st_name2fips $4)
                        psql $pg_conn_str -q -c "
                            BEGIN;
                            DELETE FROM $pg_schema_geo.tr WHERE statefp10 = '$fips';
                            DELETE FROM $pg_schema_geo.bg WHERE statefp10 = '$fips';
                            DELETE FROM $pg_schema_geo.bl WHERE statefp10 = '$fips';
                            COMMIT;
                        "
                        [ "$6" != "0" ] && db_analyze
                        ;;
                    "state-pop")
                        req_argn $# 4 "$2 $3 <state> [force?]"
                        req_state_name $4
                        
                        [ "$5" != "1" ] && req_y "Remove population data for $4?"
                        
                        fips=$(st_name2fips $4)
                        psql $pg_conn_str -q -c "
                            BEGIN;
                            DELETE FROM $pg_schema_pop.school    WHERE st_fips = '$fips';
                            DELETE FROM $pg_schema_pop.hospital  WHERE st_fips = '$fips';
                            DELETE FROM $pg_schema_pop.household WHERE st_fips = '$fips';
                            DELETE FROM $pg_schema_pop.gq        WHERE st_fips = '$fips';
                            DELETE FROM $pg_schema_pop.workplace WHERE st_fips = '$fips';
                            COMMIT;
                        "
                        [ "$6" != "0" ] && db_analyze
                        ;;
                    *) echo "$usage $2 $3{state state-geo state-pop}" && exit 1;;
                esac;;
            "stats")
                echo "geo"
                echo "    st  "$(get_tbl_rec_cnt $pg_schema_geo st)
                echo "    co  "$(get_tbl_rec_cnt $pg_schema_geo co)
                echo "    tr  "$(get_tbl_rec_cnt $pg_schema_geo tr)
                echo "    bg  "$(get_tbl_rec_cnt $pg_schema_geo bg)
                echo "    bl  "$(get_tbl_rec_cnt $pg_schema_geo bl)
                #echo "    states: $(psql $pg_conn_str -q -t -c "SELECT COUNT(*) FROM $pg_schema_geo.tr WHERE statefp10 = '$fips';") > 0 ]; then"
                echo "pop"
                echo "    school     "$(get_tbl_rec_cnt $pg_schema_pop school)
                echo "    hospital   "$(get_tbl_rec_cnt $pg_schema_pop hospital)
                echo "    household  "$(get_tbl_rec_cnt $pg_schema_pop household)
                echo "    gq         "$(get_tbl_rec_cnt $pg_schema_pop gq)
                echo "    workplace  "$(get_tbl_rec_cnt $pg_schema_pop workplace)
                echo "    person     "$(get_tbl_rec_cnt $pg_schema_pop person)
                echo "    gq_person  "$(get_tbl_rec_cnt $pg_schema_pop gq_person)
                ;;
            *) echo "$usage $2{conn exec init init-geo init-pop rm stats}" && exit 1;;
        esac;;
    "fs")
        case "$2" in
            "clean")
                [ -d $dir_rt ] && rm -fr $dir_rt/*
                ;;
            "rm-data")
                case "$3" in
                    "all")
                        req_y "Remove all downloaded data?"
                        rm -f $dir_dl_geo/*
                        rm -f $dir_dl_pop/*
                        ;;
                    "geo")
                        req_y "Remove downloaded geographic data (i.e., $dir_dl_geo/)?"
                        rm -f $dir_dl_geo/*
                        ;;
                    "pop")
                        req_y "Remove downloaded population data (i.e., $dir_dl_pop/)?"
                        rm -f $dir_dl_pop/*
                        ;;
                    *) echo "$usage $2{all geo pop}" && exit 1;;
                esac;;
            *) echo "$usage $2{clean rm-data}" && exit 1;;
        esac;;
    "help")
        ;;
    "import")
        case "$2" in
            "geo")
                req_argn $# 3 "$2 <state or - for all> [force?]"
                req_state_name $3
                
                if [ $(docker exec $docker_cont which shp2pgsql | wc | awk 'END {print $1}' | bc) == 0 ]; then
                    echo -n 'Initializing the container...'
                    docker exec $docker_cont apt update 1> /dev/null 2>&1
                    docker exec $docker_cont apt install -y --no-install-recommends postgis 1> /dev/null 2>&1  # shp2pgsql
                    echo ' done'
                fi
                
                if [ "$3" == "-" ]; then
                    db_init_geo 1
                    
                    proc_item_geo "US states      " $url_geo_st st
                    proc_item_geo "US counties    " $url_geo_co co
                    
                    for fips in "${st_fips[@]}"; do proc_item_geo "$3 tracts      " "${url_geo_tr[0]}$fips${url_geo_tr[1]}" tr $fips; done
                    for fips in "${st_fips[@]}"; do proc_item_geo "$3 block groups" "${url_geo_bg[0]}$fips${url_geo_bg[1]}" bg $fips; done
                    for fips in "${st_fips[@]}"; do proc_item_geo "$3 blocks      " "${url_geo_bl[0]}$fips${url_geo_bl[1]}" bl $fips; done
                else
                    fips=$(st_name2fips $3)
                    
                    
                    #if [ "$4" != "1" ] && [ $(psql $pg_conn_str -q -t -c "SELECT COUNT(*) FROM $pg_schema_geo.tr WHERE statefp10 = '$fips';") > 0 ]; then
                    if [ "$4" != "1" ] && [ $(get_int "SELECT COUNT(*) FROM $pg_schema_geo.tr WHERE statefp10 = '$fips';") -gt 0 ]; then
                        conf_yn "Geographic data for that state already exists. Remove it and import again?" || exit 0
                    fi
                    
                    proc_item_geo "US states      " $url_geo_st st
                    proc_item_geo "US counties    " $url_geo_co co
                    
                    proc_item_geo "$3 tracts      " "${url_geo_tr[0]}$fips${url_geo_tr[1]}" tr $fips
                    proc_item_geo "$3 block groups" "${url_geo_bg[0]}$fips${url_geo_bg[1]}" bg $fips
                    proc_item_geo "$3 blocks      " "${url_geo_bl[0]}$fips${url_geo_bl[1]}" bl $fips
                fi
                
                db_analyze
                ;;
            "pop")
                req_argn $# 3 "$2 <two-letter state code or - for all> [force?]"
                req_state_name $3
                
                if [ $(docker exec $docker_cont which python3 | wc | awk 'END {print $1}' | bc) == 0 ]; then
                    echo -n 'Initializing the container...'
                    docker exec $docker_cont apt update 1> /dev/null 2>&1
                    docker exec $docker_cont apt install -y python3 python3-pip 1> /dev/null 2>&1
                    docker exec $docker_cont pip3 install psycopg2-binary 1> /dev/null 2>&1
                    echo ' done'
                fi
                
                if [ "$3" == "-" ]; then
                    db_init_pop 1
                    for st in "${st_name[@]}"; do proc_item_pop "$st" "${url_pop[0]}$st${url_pop[1]}" $(st_name2fips $st); done
                else
                    fips=$(st_name2fips $3)

                    if [ "$4" != "1" ] && [ $(get_int "SELECT COUNT(*) FROM $pg_schema_pop.household WHERE st_fips = '$fips';") -gt 0 ]; then
                        conf_yn "Population data for that state already exists. Remove it and import again?" || exit 0
                    fi
                    
                    proc_item_pop "$3" "${url_pop[0]}$3${url_pop[1]}" $fips
                fi
                
                db_analyze
                ;;
            *) echo "$usage $2{geo pop}" && exit 1;;
        esac;;
    "info")
        echo "Environment"
        echo "    Production  $is_prod"
        echo "Directory structure"
        echo "    Root                   $dir_root            $(du -sh $dir_root | awk 'END {print $1}')"
        echo "    Runtime                $dir_rt         $(du -sh $dir_rt | awk 'END {print $1}')"
        echo "    PostgreSQL data        $dir_pg_data         $(du -sh $dir_pg_data | awk 'END {print $1}')"
        echo "    Geographic data        $dir_dl_geo     $(du -sh $dir_dl_geo | awk 'END {print $1}')"
        echo "    Population data        $dir_dl_pop     $(du -sh $dir_dl_pop | awk 'END {print $1}')"
        echo "    Disease dynamics data  $dir_dl_disdyn  $(du -sh $dir_dl_disdyn | awk 'END {print $1}')"
        echo "    Intervention data      $dir_dl_interv  $(du -sh $dir_dl_interv | awk 'END {print $1}')"
        echo "PostgreSQL server"
        echo "    Hostname  $pg_host"
        echo "    Port      $pg_port"
        echo "    Database  $pg_db"
        echo "    Username  $pg_usr"
        echo "    Password  $pg_pwd"
        ;;
    "setup")
        # Environment:
        mkdir -p $dir_root
        mkdir -p $dir_dl_geo
        mkdir -p $dir_dl_pop
        mkdir -p $dir_dl_disdyn
        mkdir -p $dir_dl_interv
        mkdir -p $dir_rt
        mkdir -p $dir_script
        mkdir -p $dir_pg_data
        
        # PostgreSQL:
        $0 stop
        docker pull postgis/postgis
        $0 start
        echo "Waiting for the server to spin up..."
        sleep 5  # TODO: Check the actual status in a loop.
        db_init 1
        ;;
    "start")
        [ $is_prod == 0 ] && docker run --rm --name $docker_cont -e POSTGRES_USER=$pg_usr -e POSTGRES_PASSWORD=$pg_pwd -d -p $pg_port:5432 -v $dir_pg_data:/$dir_pg_data_docker -v $dir_rt:$dir_rt_docker -v $dir_script:$dir_script_docker postgis/postgis > /dev/null
        ;;
    "stop")
        [ $is_prod == 0 ] && docker stop $docker_cont > /dev/null
        ;;
    "update")
        cd $HOME/bin
        rm -f ./localedb-update.bak
        mv ./localedb ./localedb-update.bak
        $cmd_dl https://raw.githubusercontent.com/momacs/localedb/master/localedb
        rm -f ./localedb-update.bak
        ;;
    "uninstall")
        req_y "This will remove all downloaded data and the contents of the '$pg_db' database. Continue?"
        $0 stop
        [ $is_prod == 1 ] && PGPASSWORD=$pg_pwd dropdb -h $pg_host -p $pg_port -U $pg_usr --if-exists $pg_db
        rm -fr $dir_root
        conf_yn "Remove this command line management tool?" && rm $0 || echo "Tool retained."
        ;;
    *) echo "Commands: db fs help import info setup start stop update uninstall";;
esac
